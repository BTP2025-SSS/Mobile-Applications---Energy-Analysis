## Sensor and Location Patterns

1. High frequency Location Updates

Problem : GPS wakes the chip every second, draining battery fast.

Eg : 

```c
    locationManager.requestLocationUpdates(
        LocationManager.GPS_PROVIDER,
        0,       // minTime = 0 ms
        0,       // minDistance = 0 meters
        locationListener
    );
```
 
Alternatives :
Like , we know some apps may not req location updates for every sec , rather we can update for 5 to 10 sec..
Use FusedLocationProviderClient (Google Play Services) which automatically balances accuracy vs power.

```c
    LocationRequest request = new LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 10000) // 10 sec
        .setMinUpdateDistanceMeters(50)  // update only if user moved 50m
        .build();

    fusedLocationClient.requestLocationUpdates(request, locationCallback, Looper.getMainLooper());
```


2. Keeping Sensors Active in Background

App listens to accelerometer/gyroscope even when the screen is off.

```c
    sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_FASTEST);
```

Alternatives :
Unregister sensor in onPause() / when screen off.
Use batching (SENSOR_DELAY_NORMAL) instead of fastest mode.

```c
    @Override
    protected void onPause() {
        super.onPause();
        sensorManager.unregisterListener(this);
    }
```

3. Using High-Accuracy GPS When Not Needed

Problem: Many apps request the highest accuracy (GPS_PROVIDER) even if the task only needs approximate location (like weather or ads). GPS uses a lot of energy compared to Wi-Fi or cell towers.

Here GPS chip is always powered on â†’ heavy battery drain.

```c
    locationManager.requestLocationUpdates(
        LocationManager.GPS_PROVIDER,
        5000,   // 5 sec
        10,     // 10 meters
        locationListener
    );
```

Alternative: Use FusedLocationProviderClient with PRIORITY_BALANCED_POWER_ACCURACY (uses Wi-Fi + cell when possible).


```c
    LocationRequest request = new LocationRequest.Builder(Priority.PRIORITY_BALANCED_POWER_ACCURACY, 60000).build();
    // here we requested for every 1 min
```


4. Polling Instead of Event-Driven APIs

Problem: Some apps poll sensors frequently instead of using event-driven APIs (like step counter, significant motion sensor, geofencing).

```c
    // Polling accelerometer every 200 ms
    sensorManager.registerListener(this, accelerometer, 200000);
```

Better Alternative: Use event-based sensors:

```c
    // Register for step counter events
    sensorManager.registerListener(this, stepCounter, SensorManager.SENSOR_DELAY_NORMAL);
```