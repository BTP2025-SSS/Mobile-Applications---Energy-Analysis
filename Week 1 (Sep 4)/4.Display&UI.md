## Display and UI Patterns

### Garbage collection

```c

//before
for (int i = 0; i < items.size(); i++) {
    StringBuilder sb = new StringBuilder();
    sb.append(items.get(i).getName());
    // code
}
//after
//instead of allocating new object evrytime, we declare and reuse it
StringBuilder sb = new StringBuilder();
for (int i = 0; i < items.size(); i++) {
    sb.setLength(0); // reset instead of allocating
    //// code 
}

```



## onBindViewHolder
```c
//when ever we scsroll this function is called, creating short lived objects like strings
override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    val item = dataList[position]
    val styled = SpannableString(item.title)   
}
//after
//reuse the strings instead of creating it evry time when needed, which reduces per scroll allocations, decreses g
private val reusableSpannable = SpannableStringBuilder()

override fun onBindViewHolder(holder: ViewHolder, position: Int) {
    val item = dataList[position]
    reusableSpannable.clear()
    reusableSpannable.append(item.title)
}
```


## RecyclerView.RecycledViewPool
```c
// as we will have 10-12 viewholder for dispaly , we can ust reuse them but when we need some additonal holders, we can't waste cpu on creating  new holders every time, so we create a pool so that we can fetch when needed.
class OuterAdapter : RecyclerView.Adapter<...>() {
    private val sharedPool = RecyclerView.RecycledViewPool()

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val viewHolder = // inflate...
        viewHolder.innerRecycler.setRecycledViewPool(sharedPool)
        return viewHolder
    }
}
// setItemViewCacheSize to cache the recent view holder data, if we scroll back
```

## Custom Views
```c
// generally we will have many views for an simple application ui, like text, image, etc.
// But if they are seperate, each of this view contains its own attributes, which are needed for rendering,
// so as the np.of views increses, the memeory consumption increases, 
// Soo we use Custom views for it.

// Caching Static layout
// when we need to render any view, we need to render text and everything,
// But to render these texts we need to caluculate the Static layout of the text view, so instead of calucating evry time we will cache it.

fun setMessage(text: String) {
        message = text
        invalidate() // triggers onDraw
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        //Build StaticLayout every frame -> expensive
        val layout = StaticLayout.Builder
            .obtain(message, 0, message.length, paint, width)
            .build()

        layout.draw(canvas)
    }

//after
fun setMessage(text: String) {
        // Only create StaticLayout once
        layoutCache = StaticLayout.Builder
            .obtain(text, 0, text.length, paint, width)
            .build()

        invalidate()
    }

    override fun onDraw(canvas: Canvas) {
        super.onDraw(canvas)

        // Just reuse cached layout
        layoutCache?.draw(canvas)
    }
```

```c

//before
dataList = newList
adapter.notifyDataSetChanged()
//after
// just rerenderes the part that is modified by using Diffutil
val diffCallback = MyDiffUtil(oldList, newList)
val diffResult = DiffUtil.calculateDiff(diffCallback)

dataList = newList
diffResult.dispatchUpdatesTo(adapter)
```



## Move Heavy Work Out of onBindViewHolder
```c
//before
override fun onBindViewHolder(holder: VH, position: Int) {
    val item = dataList[position]
    holder.textView.text = SimpleDateFormat("yyyy-MM-dd").format(item.date) // expensive!
}
//after
// do those things before hand
// Format dates once when preparing data, Binding becomes lightweight ,just setting values.
val formattedDate = dateFormatter.format(item.date)
holder.textView.text = formattedDate

```

## Avoid String Concatenation in Bind
```c
//befoe
holder.textView.text = "User: " + item.name
//after
//avoids tempory string allocation 
holder.textView.text = "User: ${item.name}" // Kotlin compiles efficiently




```