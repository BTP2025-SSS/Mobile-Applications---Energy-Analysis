## CPU-Intensive Patterns

1. Busy Wait Looping : A busy-wait loop is when code keeps looping repeatedly to "wait" for some condition to become true, instead of  
properly sleeping or waiting.

Pattern : // Busy-wait loop
```c
    while (!dataAvailable) {
        // do nothing, just keep looping
    }
    processData();
```

Instead of burning CPU cycles, we let the system put the thread to sleep or wait properly until the condition changes.
Some Better Alternatives : We can simply use "Sleep with delay" , "Wait / Notify mechanism" , "Blocking Queues"


2. Ineffecient Loops / Redundant Computations : Calculating already precomputed results , can lead to redundant operations and increase 
cpu usage.

Patterns : 
Some patterns may be , like calculating the size of list everytime , instead of storing in a variable..
Sometimes we will recursively calculate the results , instead we can cache them somewhere , and use them when it is necessary..


3. Overusing the Main/UI Thread for Heavy Tasks : Doing CPU-heavy work (like image filtering, encryption, or JSON parsing) on the main thread keeps CPU busy and freezes UI, leading to more energy usage (screen stays on longer).

Patterns : 
```c
    // BAD: running image processing on UI thread
    public void onClick(View v) {
        applyFilterToImage(largeBitmap);  // blocks UI + eats CPU
    }

```
Problem: Heavy work blocks UI → app freezes, CPU maxed, ANR risk, battery drains.
Fix: Move heavy work to background (Thread, Executor, Coroutine), update UI only after work is done.
Impact: Smooth UI + lower energy + better user experience.                                 

4. We can also take care about inefficient algorithms .

5. Unbounded Thread Spawning / Parallelism Misuse

Problem : 
Creates hundreds of threads → CPU context switching overhead.
Instead of speeding up, it slows down + wastes battery.

```c
    for (File f : files) {
        new Thread(() -> encryptFile(f)).start();  // starts too many threads!
    }
```

Alternative : Use thread pools / executors:

```c
    ExecutorService pool = Executors.newFixedThreadPool(4);
    for (File f : files) {
        pool.submit(() -> encryptFile(f));
    }
```

Impact: Limited, efficient parallelism → better throughput, lower CPU overhead.

